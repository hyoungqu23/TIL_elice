<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CRUD</title>
  <style>
    a {
      color: black; 
      text-decoration: none;
    }
  </style>
  <script>
    let title = ['HTML', 'CSS', 'JavaScript',];

    let arrData = [
      [1, 'HTML', 'HTML is ...',],
      [2, 'CSS', 'CSS is ...',],
      [3, 'JavaScript', 'JavaScript is ...',],
    ]

    let objData = [
      {id: 1, title: 'HTML', body: 'HTML is ...',},
      {id: 2, title: 'CSS', body: 'CSS is ...',},
      {id: 3, title: 'JavaScript', body: 'JavaScript is ...',},
    ];
  </script>
</head>
<body>
  <h1>
    <a href="index.html" onclick="() => {
    event.preventDefault();
    document.querySelector('article h2').innerHTML = 'WEB';
    document.querySelector('article p').innerHTML = 'Hello, WEB!';
    }">WEB</a>
  </h1>
  <nav>
    <ol>
      <!-- 동적 변경 대상
        <li><a href="/read/1.html">HTML</a></li>
        <li><a href="/read/2.html">CSS</a></li>
       -->
    </ol>
  </nav>
  <article>
    <!-- 동적 변경 대상
      <h2>Welcome</h2>
      <p>Hello, WEB</p>
     -->
  </article>
  <ul id="control">
    <!-- 동적 변경 대상
      <li><a href="/create">CREATE</a></li>
      <li><a href="/update">UPDATE</a></li>
      <li><a href="/delete">DELETE</a></li>
     -->
  </ul>
  <script>
    // 재할당 불가 주제 데이터 설정
    const topics = [
      {id: 1, title: 'HTML', body: 'HTML is ...'},
      {id: 2, title: 'CSS', body: 'CSS is ...'},
      {id: 3, title: 'JavaScript', body: 'JavaScript is ...'},
    ];

    // 선택되어 있는 id 값 할당할 데이터 추가
    let selectedId = null;

    // Navigation list click event handler 선언
    // 필요 기능: (1) 링크 작동 하지 않아야 한다. (2) id 값을 가져와야 한다. (3) id 값과 일치하는 topics의 원소를 찾아야 한다. (4) 본문을 만든다. (5) 본문을 출력한다.
    function navHandler(e) {
      // (1) 링크 작동을 막는다.
      e.preventDefault();
      // (2) id 값을 추출한다. (e.target.id => from String to Number)
      selectedId = +e.target.id;
      // (3) id 값과 일치하는 topics의 원소를 찾아야 한다.
      // (4) 본문을 만든다.
      // (5) 본문을 출력한다.
      read();   // (3) ~ (5) 작업은 추후 반복될 여지가 있어 독립적인 하나의 함수로 설계하고 생성한 후 호출한다.
    }

    // Navigation Renderer
    function nav() {
      const tag = topics.map(el => `<li><a href='/read/${el.id}.html' id='${el.id}' onclick='navHandler(event);'>${el.title}</a></li>`).join(" ");
      document.querySelector('nav>ol').innerHTML = tag;
    }

    // 각 기능 함수 구현
    function welcome () {

    }

    // Nav Handler에서 호출될 예정
    function read() {
      // filter의 콜백 함수는 일치할 때 true, 일치하지 않을 때 false를 return한다. 즉, 콜백 함수의 return 값이 true인 원소만으로 담은 배열을 반환한다.(원본 수정 X)
      // (3) 
      // topics.filter(el => { if (el.id === selectedId) { return true; } else { return false; } });의 축약
      const topic = topics.filter(el => el.id === selectedId);
      // 다른 방법: const topic = topics.filter(el => el.id === selectedId)[0];
      
      // (4)
      const content = `<h2>${topic[0].title}</h2><p>${topic[0].body}</p>`
      // 다른 방법: const content = `<h2>${topic.title}</h2><p>${topic.body}</p>`
      
      // (5)
      document.querySelector('article').innerHTML = content;
    }

    function create() {

    }

    function update() {

    }

    // delete는 예약어이기 때문에 함수 이름으로 사용 불가능
    function del() {

    }

    // UI 동적 Renderer(#control list)
    function control () {

    }

    // 최초 출력을 위한 함수 호출
    nav();
  </script>
</body>
</html>